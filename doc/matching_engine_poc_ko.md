# PoC 매칭 엔진 명세서

## 1. 소개

이 문서는 개념 증명(PoC) 매칭 엔진의 아키텍처 비전을 설명합니다. 이 프로젝트의 주요 목표는 프로덕션 수준의 시스템을 개발하는 것이 아니라, 다양한 도전적인 요구사항 하에서 복잡한 시스템을 설계하기 위한 탐구의 장을 마련하는 것입니다. 이를 통해 고도의 확장성과 복원력이 요구되는 분야, 특히 Web3 애플리케이션과 같은 미래 작업에 적용할 수 있는 깊은 이해를 증진하고 새로운 관점을 발견하고자 합니다.

구현에는 Go 언어가 활용될 예정이며, 이는 단순성, 생산성, 그리고 명확한 코드에 대한 강조 때문입니다. 매칭 엔진과 같이 중요하고 복잡한 시스템에서는 코드의 명확성이 오류를 최소화하는 데 가장 중요하며, 사소한 혼란이라도 중대한 문제로 이어질 수 있습니다. 매칭 엔진 구성 요소는 더 넓은 시스템 내에서 본질적으로 오류가 없어야 합니다.

## 2. 핵심 아키텍처 원칙 및 아이디어

### 2.1. 기능적 범위

매칭 엔진 서버는 주문 매칭의 핵심 로직에만 집중할 것입니다. 주문 매칭과 관련 없는 비즈니스 로직은 포함하지 않을 것입니다. 그러나 유연한 "afterOrder" 핸들러 함수를 지원할 것입니다. 이 메커니즘을 통해 핵심 매칭 프로세스를 차단하지 않고, 상태 변경 사항을 PostgreSQL 데이터베이스에 지속성을 위해 업데이트하는 것과 같은 추가 프로세스를 동시에 실행할 수 있습니다. 각 주문에는 참여자를 고유하게 식별하기 위한 `orderer_id`가 포함될 것입니다.

### 2.2. 트랜잭션 순서 및 동시성

주문 매칭의 근본적인 제약은 본질적인 순차적 성격입니다. 각 들어오는 트랜잭션(주문)은 종종 이전 트랜잭션의 결과 상태에 의존합니다. 처리 순서를 변경하면 매칭 엔진의 결과가 직접적으로 바뀔 것입니다. 결과적으로, 트랜잭션 순서는 엄격하게 보존되어야 하므로 핵심 매칭 프로세스는 전통적인 의미에서 진정으로 병렬화될 수 없습니다.

그러나 병렬 실행이 가능할 수 있는 특정 시나리오에 대한 탐구가 이루어질 것입니다. 예를 들어, 중요한 오더북 범위에 대한 뮤텍스 잠금이 필요 없는 특정 "취소" 주문은 잠재적으로 병렬로 처리될 수 있습니다. 또한 고빈도 거래 환경에서는 유동성이 좁은 가격 범위 내에 집중되는 경향이 있다는 가설에 대해 추가적인 고려가 이루어질 것입니다. 이것이 사실이라면, "실제 거래 실행이 여전히 제한적인" 이 "핫" 가격 범위를 크게 벗어나는 주문의 처리를 병렬화하는 것이 가능할 수 있습니다. 이 접근법의 실행 가능성은 실질적인 성능 이점 없이 과도한 복잡성을 도입하지 않도록 신중한 평가가 필요합니다.

### 2.3. 시스템 구성

매칭 엔진은 허용되는 가장 작은 가격 증분을 정의하는 `minimum_tick` 크기와 같은 구성 가능한 매개변수를 지원할 것입니다.

### 2.4. 확장성 접근 방식

초기 설계는 다른 자산에 대해 여러 서버를 배포하는 것을 피하는 것을 목표로 하지만, 서버 책임을 분할하는 메커니즘이 고려될 것입니다. 이를 통해 지속적으로 많은 주문 흐름을 보이는 자산에 별도의 인스턴스를 할당하여 병목 현상을 방지함으로써 매칭 엔진의 수평적 확장이 가능해질 것입니다.

### 2.5. 주문 유형

표준 시장가, 지정가, 손절매 주문 외에도, 다양한 거래 전략에 중요한 보다 전문화된 주문 유형에 대한 지원을 탐색할 것입니다:

*   **Post-Only 주문:** 오더북에 유동성을 추가하도록 설계되었습니다. Post-Only 주문은 기존 주문과 즉시 일치하지 않는 경우에만 실행됩니다. 만약 "스프레드를 넘어서" 시장가 주문처럼 행동하게 된다면 거부될 것입니다. 이 유형은 테이커 수수료를 피하여 메이커 리베이트를 얻으려는 유동성 공급자에게 가치가 있습니다. [1]
*   **전량 체결 조건 (AON):** 전체가 실행되거나 전혀 실행되지 않아야 하는 주문입니다.
*   **전량 체결 또는 취소 (FOK):** 즉시 전체가 실행되거나 취소되어야 하는 주문입니다.
*   **즉시 체결 또는 취소 (IOC):** 즉시 (부분적으로 또는 전체적으로) 실행되고, 실행되지 않은 부분은 취소되어야 하는 주문입니다. [1]

### 2.6. 테스트 프레임워크

견고한 테스트 프레임워크는 매칭 엔진의 성능과 정확성을 검증하는 데 중요합니다. 이 프레임워크는 다음을 수행합니다:

*   기존 오픈 소스 매칭 엔진 솔루션과 처리 속도를 벤치마킹할 수 있도록 합니다.
*   다양한 특수 시나리오 하에서 포괄적인 테스트를 용이하게 합니다. 이는 다양한 거래 시나리오를 탐색하고 특정 테스트 데이터 세트를 생성하여 프로젝트의 기능이 철저히 검증되도록 하는 것을 포함합니다.

### 2.7. 블록체인 아키텍처로부터의 통찰

블록체인 플랫폼, 특히 이더리움의 운영 특성은 매칭 엔진에 귀중한 통찰을 제공합니다. OKX와 같은 플랫폼이 이더리움의 코드베이스에서 자체 블록체인을 구축하기로 결정한 이유는 매칭 엔진 요구사항과 공명합니다:

*   **지갑 및 인증 시스템:** 안전한 사용자 식별 및 자산 관리.
*   **순차적 트랜잭션 처리:** 블록체인 트랜잭션의 고유한 순서 있는 성격은 매칭 엔진의 엄격한 트랜잭션 순서 요구사항과 일치합니다.
*   **24/7 무중단 운영:** 블록체인 네트워크는 지속적인 가용성을 위해 설계되었으며, 이는 암호화폐 거래소의 중요한 요구사항입니다.
*   **보장된 트랜잭션 전파:** 유효한 트랜잭션은 일단 방송되면 전파되어 결국 확인되도록 설계되어 "누락된" 사용자 트랜잭션을 방지합니다.

### 2.8. 인메모리 상태 관리 (LMAX에서 영감)

LMAX와 같은 아키텍처에서 영감을 받아 인메모리 상태 관리 접근 방식이 우선시될 것입니다. 이는 고빈도 거래 환경에서 가장 중요한 상당한 속도 이점을 제공합니다. 24/7 암호화폐 거래소의 경우, 지속성을 위해 일부 속도를 희생하더라도 시스템 다운타임은 매우 문제가 됩니다. 따라서 `afterOrder` 핸들러를 통해 지속성을 신중하게 관리하면서 인메모리 작업을 선호하는 것이 이 요구에 부합합니다. [2]

또한, 특히 물리적 서버가 사용자와 멀리 떨어져 있을 때의 네트워크 지연 시간의 영향은 트랜잭션 크기에 대한 신중한 고려를 필요로 합니다. 각 트랜잭션의 크기를 최소화하고 압축 해제된 트랜잭션의 매개변수 수를 줄여 네트워크 전송 효율을 최적화하려는 노력이 이루어질 것입니다. [2]

## 참고 자료

[1] https://b2broker.com/news/what-is-cryptocurrency-matching-engine/
[2] https://martinfowler.com/articles/lmax.html#KeepingItAllInMemory

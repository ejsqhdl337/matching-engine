# PoC 매칭 엔진 명세서

## 1. 소개

이 문서는 개념 증명(PoC) 매칭 엔진의 아키텍처 비전을 설명합니다. 이 프로젝트의 주요 목표는 프로덕션 준비 시스템을 개발하는 것이 아니라, 다양한 도전적인 요구 사항 하에서 복잡한 시스템을 설계하기 위한 탐구의 장을 마련하는 것입니다. 이를 통해 특히 Web3 애플리케이션과 같이 높은 확장성과 복원력이 요구되는 도메인에서 향후 작업에 적용할 수 있는 더 깊은 이해를 증진하고 새로운 관점을 발견하는 것을 목표로 합니다.

구현은 단순성, 생산성 및 명확한 코드에 중점을 둔 Go를 활용할 것입니다. 매칭 엔진과 같이 중요하고 복잡한 시스템에서는 코드 명확성이 오류를 최소화하는 데 가장 중요하며, 사소한 혼란이라도 중대한 문제로 이어질 수 있습니다. 매칭 엔진 구성 요소는 더 넓은 시스템 내에서 본질적으로 오류가 없어야 합니다.

## 2. 핵심 아키텍처 원칙 및 아이디어

### 2.1. 이벤트 기반 아키텍처 및 데이터 흐름

매칭 엔진은 높은 처리량과 낮은 지연 시간을 보장하기 위해 이벤트 기반 아키텍처를 사용합니다. 전체 데이터 흐름은 다음과 같이 시각화할 수 있습니다.

```+-------------------+     +-------------------+     +-------------------+
|   입력 이벤트      |     |    매칭 엔진      |     |   출력 이벤트      |
|       흐름        |     |    (오더 북)      |     |       흐름        |
+-------------------+     +-------------------+     +-------------------+
| 이벤트 링 버퍼    | --- 소비 --->  | bids              | --- 생성 --->  | 이벤트 링 버퍼    |
|-------------------|                     |-------------------|                     |-------------------|
| 이벤트 핸들러     |                     | asks              |                     | 이벤트 핸들러     |
+-------------------+                     +-------------------+                     +-------------------+
        |                                                                                |
        |                                                                                |
        +-----------------------------> +-----------------+ <----------------------------+
                                        |   이벤트 로거   |
                                        +-----------------+
                                          (로깅, RDBMS/파일에 저장 책임)

출력 이벤트 유형:
- 오더 북 스냅샷
- 거래
- 시장 가격
```

**구성 요소:**

*   **입력 이벤트 흐름:**
    *   **이벤트 링 버퍼(입력):** 매칭 엔진에서 처리되기 전에 새로운 주문, 수정 또는 취소와 같은 들어오는 이벤트를 버퍼링하는 고성능, 저지연 큐입니다.
    *   **이벤트 핸들러(입력):** 입력 링 버퍼에서 이벤트를 소비하여 초기 유효성 검사를 수행하고 핵심 매칭 로직을 위해 준비합니다.
*   **매칭 엔진(오더 북):**
    *   이벤트 처리를 담당하는 핵심 구성 요소입니다. `bids`(매수 주문) 및 `asks`(매도 주문)의 현재 상태를 유지하는 중앙 `오더 북`을 포함합니다.
*   **출력 이벤트 흐름:**
    *   **이벤트 링 버퍼(출력):** 매칭 엔진에서 생성된 결과(예: 확인된 거래, 오더 북 업데이트)를 다운스트림 시스템으로 전달하기 전에 버퍼링합니다.
    *   **이벤트 핸들러(출력):** 출력 링 버퍼에서 다음과 같은 다양한 유형의 이벤트를 생성합니다.
        *   **오더 북 스냅샷:** 오더 북 상태의 주기적 또는 이벤트 기반 캡처.
        *   **거래:** 매수 및 매도 간의 실행된 매칭에 대한 세부 정보.
        *   **시장 가격:** 거래 또는 오더 북 활동에서 파생된 현재 시장 가격에 대한 업데이트.
*   **이벤트 로거:**
    *   이 구성 요소는 모든 중요한 이벤트가 기록되도록 하는 중요한 책임을 집니다. 입력 및 출력 이벤트 핸들러 모두에서 입력을 받아 수신된 주문, 처리된 이벤트 및 생성된 결과에 대한 포괄적인 로깅을 보장합니다. 이러한 로그의 지속성 메커니즘(예: RDBMS, 파일 시스템)은 특정 내구성 및 검색 요구 사항에 따라 결정됩니다.

### 2.2. 기능적 범위

매칭 엔진 서버는 주문 매칭의 핵심 로직에만 독점적으로 초점을 맞출 것입니다. 주문 매칭과 관련 없는 비즈니스 로직은 포함하지 않습니다. 그러나 유연한 "afterOrder" 핸들러 함수를 지원할 것입니다. 이 메커니즘은 핵심 매칭 프로세스를 차단하지 않고 지속성을 위해 PostgreSQL 데이터베이스에 상태 변경을 업데이트하는 것과 같은 추가 프로세스의 동시 실행을 허용합니다. 각 주문에는 참가자를 고유하게 식별하기 위한 `orderer_id`가 포함되어 외부 사용자 관리 또는 회계 시스템과의 통합을 용이하게 합니다.

### 2.3. 트랜잭션 시퀀싱 및 동시성

주문 매칭의 근본적인 제약은 본질적인 순차적 특성입니다. 들어오는 각 트랜잭션(주문)은 종종 이전 트랜잭션의 결과 상태에 의존합니다. 처리 순서를 변경하면 매칭 엔진의 결과가 직접적으로 변경됩니다. 결과적으로 트랜잭션 순서는 엄격하게 보존되어야 하므로 핵심 매칭 프로세스는 전통적인 의미에서 진정으로 병렬화될 수 없습니다.

그러나 제한된 병렬 실행이 가능할 수 있는 특정 시나리오를 탐색할 것입니다. 예를 들어, 활성 매칭이 발생하지 않는 가격 범위에 영향을 미치는 특정 "취소" 주문(즉, 중요하고 활발하게 거래되는 오더 북 수준에 대한 뮤텍스 잠금이 필요하지 않음)은 잠재적으로 병렬로 처리될 수 있습니다. 이는 이러한 "범위 밖" 주문 취소가 전체 거래 활동의 작은 부분을 차지한다는 점을 감안할 때 최소한의 이득을 위해 과도한 복잡성을 도입하지 않도록 신중하게 고려해야 하는 간략한 아이디어입니다.

### 2.4. 시스템 구성

매칭 엔진은 허용 가능한 가장 작은 가격 증분을 정의하고 무한히 작은 가격 차이에 대한 주문을 방지하는 데 도움이 되는 `minimum_tick` 크기와 같은 구성 가능한 매개변수를 지원합니다.

### 2.5. 확장성 접근 방식

초기 설계는 단일 논리적 매칭 엔진을 목표로 하지만, 아키텍처는 지속적으로 많은 주문 흐름을 보이는 특정 자산 또는 자산 그룹에 별도의 매칭 엔진 인스턴스를 할당하여 다른 자산의 병목 현상을 방지함으로써 수평적 확장을 허용합니다.

### 2.6. 주문 유형

표준 시장가, 지정가 및 손절매 주문 외에도 엔진은 다양한 거래 전략에 중요한 보다 전문화된 주문 유형에 대한 지원을 탐색할 것입니다.

*   **Post-Only 주문:** 오더 북에 유동성을 추가하도록 설계되었습니다. Post-Only 주문은 기존 주문과 즉시 일치하지 않는 경우에만 실행됩니다. "스프레드를 넘어서" 시장가 주문으로 작용하는 경우 거부됩니다. 이 유형은 테이커 수수료를 피하여 메이커 리베이트를 얻으려는 유동성 공급자에게 유용합니다. [1]
*   **All-or-None (AON):** 전체가 실행되거나 전혀 실행되지 않아야 하는 주문.
*   **Fill-or-Kill (FOK):** 즉시 전체가 실행되거나 취소되어야 하는 주문.
*   **Immediate-or-Cancel (IOC):** 즉시 실행(부분적으로 또는 전체적으로)되고 실행되지 않은 부분은 취소되어야 하는 주문. [1]

### 2.7. 테스트 프레임워크

강력한 테스트 프레임워크는 매칭 엔진의 성능과 정확성을 검증하는 데 중요합니다. 이 프레임워크는 다음을 수행합니다.

*   기존 오픈 소스 매칭 엔진 솔루션에 대한 처리 속도 벤치마킹을 활성화합니다.
*   다양한 특수 시나리오에서 포괄적인 테스트를 용이하게 합니다. 여기에는 다양한 거래 시나리오를 탐색하고 프로젝트의 기능이 철저히 검증되도록 특정 테스트 데이터 세트를 생성하는 것이 포함됩니다.

### 2.8. 블록체인 아키텍처의 통찰력

블록체인 플랫폼, 특히 이더리움의 운영 특성은 매칭 엔진에 대한 귀중한 통찰력을 제공합니다. OKX와 같은 플랫폼이 자체 블록체인(예: 이더리움 코드베이스에서)을 구축하기로 선택한 이유는 매칭 엔진 요구 사항과 공명합니다.

*   **지갑 및 인증 시스템:** 강력한 클라이언트 상호 작용 및 상태 관리를 위한 영감.
*   **순차적 트랜잭션 처리:** 블록체인 트랜잭션의 고유한 순서 지정 특성은 매칭 엔진에서 엄격한 트랜잭션 시퀀싱 및 결정론적 결과에 대한 필요성과 일치합니다.
*   **24/7 무중단 운영:** 블록체인 네트워크는 지속적인 가용성을 위해 설계되었으며, 이는 암호화폐 거래소의 중요한 요구 사항입니다.
*   **보장된 트랜잭션 전파:** 유효한 트랜잭션은 일단 브로드캐스트되면 전파되어 결국 확인되도록 설계되어 "누락된" 사용자 트랜잭션을 방지합니다.

### 2.9. 인메모리 상태 관리 (LMAX에서 영감)

LMAX와 같은 아키텍처에서 영감을 받아 인메모리 상태 관리 접근 방식을 우선시할 것입니다. 이는 고빈도 거래 환경에 가장 중요한 상당한 속도 이점을 제공합니다. 24/7 암호화폐 거래소의 경우 모든 시스템 다운타임은 매우 문제가 됩니다. 따라서 인메모리 작업을 우선시하면서 지속성을 전략적으로 관리(예: 비동기 업데이트를 위한 `afterOrder` 핸들러를 통해)하는 것은 이러한 요구에 부합합니다. [2]

또한, 특히 물리적 서버가 사용자와 멀리 떨어져 있을 때 네트워크 지연 시간의 영향은 트랜잭션 크기를 신중하게 고려해야 합니다. 각 트랜잭션 페이로드의 크기를 최소화하고 매개변수 수를 최적화하기 위해 노력할 것이며, 잠재적으로 Protobuf와 같은 효율적인 이진 직렬화 프로토콜을 활용하여 네트워크 전송 비용을 줄일 것입니다. 이 최적화는 또한 인메모리 데이터 구조로 확장되어, 스마트 계약 개발자가 고정된 EVM 워드 크기 내에서 효율적인 사용을 위해 데이터 구조를 최적화하는 것과 유사하게 핵심 유형(예: "Order" 유형)의 메모리 공간을 최소화하는 것을 고려할 것입니다.

## 참고 자료

[1] https://b2broker.com/news/what-is-cryptocurrency-matching-engine/
[2] https://martinfowler.com/articles/lmax.html#KeepingItAllInMemory

## 더 보기

*   **최소 LMAX 개념 구현 (Python):** https://github.com/quantyle/matching-engine
